<!DOCTYPE html><html lang="zn"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>Lidan的技术小窝</title><meta name="author" content="Lidan"><link rel="shortcut icon" href="/img/favicon.png"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css"><meta name="generator" content="Hexo 5.2.0"></head><body><header id="page_header"><div class="header_wrap"><div id="blog_name"><a class="blog_title" id="site-name" href="/">Lidan的技术小窝</a></div><button class="menus_icon"><div class="navicon"></div></button><ul class="menus_items"><li class="menus_item"><a class="site-page" href="/#Publications"> Publications</a></li><li class="menus_item"><a class="site-page" href="/"> About</a></li><li class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://crazyweirdo.xyz"> Blog</a></li></ul></div></header><main id="page_main"><div class="side-card sticky"><div class="card-wrap" itemscope itemtype="http://schema.org/Person"><div class="author-avatar"><img class="avatar-img" src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/profile.png'" alt="avatar"></div><div class="author-discrip"><h3>Lidan</h3><p class="author-bio">Your biography can be writed down here.</p></div><div class="author-links"><button class="btn m-social-links">Links</button><ul class="social-icons"><li><a class="social-icon" href="/" target="_blank"><i class="fab fa-twitter" aria-hidden="true"></i></a></li><li><a class="social-icon" href="/" target="_blank"><i class="fab fa-facebook-square" aria-hidden="true"></i></a></li><li><a class="social-icon" href="github.com/lidan233" target="_blank"><i class="fab fa-github" aria-hidden="true"></i></a></li><li><a class="social-icon" href="/" target="_blank"><i class="fab fa-stack-overflow" aria-hidden="true"></i></a></li><li><a class="social-icon" href="/" target="_blank"><i class="fab fa-linkedin" aria-hidden="true"></i></a></li><li><a class="social-icon" href="/" target="_blank"><i class="fab fa-weibo" aria-hidden="true"></i></a></li><li><a class="social-icon" href="/" target="_blank"><i class="fab fa-weixin" aria-hidden="true"></i></a></li><li><a class="social-icon" href="3235488378" target="_blank"><i class="fab fa-qq" aria-hidden="true"></i></a></li><li><a class="social-icon" href="yuanli@zju.edu.cn" target="_blank"><i class="fas fa-envelope" aria-hidden="true"></i></a></li><li><a class="social-icon" href="/" target="_blank"><i class="fas fa-rss" aria-hidden="true"></i></a></li></ul><ul class="social-links"><li><a class="e-social-link" href="/" target="_blank"><i class="fas fa-graduation-cap" aria-hidden="true"></i><span>Google Scholar</span></a></li><li><a class="e-social-link" href="/" target="_blank"><i class="fab fa-orcid" aria-hidden="true"></i><span>ORCID</span></a></li></ul></div><a class="cv-links" href="/attaches/CV.pdf" target="_blank"><i class="fas fa-file-pdf" aria-hidden="true"><span>My Detail CV.</span></i></a></div></div><div class="page" itemscope itemtype="http://schema.org/CreativeWork"><h2 class="page-title">gpu-- 报告总结及展望</h2><article><h1 id="gpu报告"><a href="#gpu报告" class="headerlink" title="gpu报告"></a>gpu报告</h1><h2 id="1-环境说明"><a href="#1-环境说明" class="headerlink" title="1 环境说明"></a>1 环境说明</h2><h3 id="1-1-实验环境"><a href="#1-1-实验环境" class="headerlink" title="1.1 实验环境"></a>1.1 实验环境</h3><blockquote>
<ul>
<li><input checked="" disabled="" type="checkbox"> 显卡:GTX 1060 3GB </li>
<li><input checked="" disabled="" type="checkbox"> CPU: AMD 3090xt</li>
<li><input checked="" disabled="" type="checkbox"> Memory: 内存64GB</li>
<li><input checked="" disabled="" type="checkbox"> 环境证明: </li>
</ul>
<p>GPU证明</p>
<div align='center'>
<img src="/images/2020-11-20-21-23-00.png" alt="drawing" width="700"/>
</div>
CPU证明
<div align='center'>
<img src="/images/2020-11-20-21-25-19.png" alt="drawing" width="700"/>
</div>
</blockquote>
<h3 id="1-2-计时说明"><a href="#1-2-计时说明" class="headerlink" title="1.2 计时说明"></a>1.2 计时说明</h3><blockquote>
<p>计时有两个标准</p>
<ul>
<li>第一个标准为：开始发送数据到gpu，到计算结果完全发送回cpu</li>
<li>第二个标准为：核函数的执行时间。 </li>
</ul>
</blockquote>
<h2 id="2-实验思路及结果"><a href="#2-实验思路及结果" class="headerlink" title="2 实验思路及结果"></a>2 实验思路及结果</h2><h3 id="2-1-自碰撞检测"><a href="#2-1-自碰撞检测" class="headerlink" title="2.1 自碰撞检测"></a>2.1 自碰撞检测</h3><h4 id="2-1-1-gpu思路1"><a href="#2-1-1-gpu思路1" class="headerlink" title="2.1.1 gpu思路1"></a>2.1.1 gpu思路1</h4><p>在caffe的实现中，贾扬青说到：将数据在CPU中进行展开，尽量减少GPU的访问显存的操作，这样可以提交性能。但是提高性能的同时会带来CPU的内存占用和显存的内存占用。可能会导致你必须将数据分块，这样碰撞检测的过程就变成了两个for循环，每个数据分块和每个分块之间的碰撞。 </p>
<blockquote>
<ul>
<li>思路简述：<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1: 将数据展开，发送给GPU的是每个三角形的vertex数据的序列，而非是每个三角形的vertex索引序列和所有的vertex数据。</span><br><span class="line">2. 将数据发送到gpu，通过tri_contact函数进行求交。</span><br></pre></td></tr></table></figure></li>
<li>方法优点 <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 从理论上来讲，通过显著减少GPU访问全局显存的次数（尽管GPU会有延迟掩藏，也无法完全消除），可以减少时间的浪费。</span><br></pre></td></tr></table></figure></li>
<li>方法坏处：<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 大量浪费了显存和内存，但是浪费是在常数倍限度内，并没有提升一个量级。</span><br></pre></td></tr></table></figure></li>
<li>实验结果计时：</li>
</ul>
</blockquote>
<blockquote>
<p>全部GPU时间<br><img src="/images/2020-11-20-22-12-17.png"><br>核函数时间<br><img src="/images/2020-11-20-22-34-06.png"></p>
<ul>
<li> 实验结果显示<br><img src="/images/2020-11-20-22-13-02.png"></li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>核函数如下：<br>该代码仅仅使用了一次atomicadd操作，但是代码存在单个面片碰撞超过32时的计算结果，可能会出现错误。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__global__ <span class="keyword">void</span>  <span class="title">gpu_selfcheck</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                                vec3fcu* data,</span></span></span><br><span class="line"><span class="function"><span class="params">                                vec3icu* dataid,</span></span></span><br><span class="line"><span class="function"><span class="params">                                vec2fcu* res,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span>* ressize,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> leftstart,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> leftsize,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> blockid = gridDim.x*blockIdx.y + blockIdx.x ;</span><br><span class="line">    <span class="keyword">int</span> threadid = blockDim.x * threadIdx.y + threadIdx.x ;</span><br><span class="line">    <span class="keyword">int</span> threadsize = blockDim.x * blockDim.y ;</span><br><span class="line">    __shared__ <span class="keyword">int</span> mutexx ;</span><br><span class="line">    __shared__ <span class="keyword">int</span> contacted[<span class="number">32</span>] ;</span><br><span class="line">    mutexx  = <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(blockid&lt;leftsize &amp;&amp; (blockid+leftstart)&lt;size )</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftcur = (leftstart + blockid)*<span class="number">3</span>  ;</span><br><span class="line">        vec3fcu leftdata1 = data[ leftcur ] ;</span><br><span class="line">        vec3fcu leftdata2 = data[ leftcur + <span class="number">1</span>] ;</span><br><span class="line">        vec3fcu leftdata3 = data[ leftcur + <span class="number">2</span>] ;</span><br><span class="line">        vec3icu leftid = dataid[leftstart+blockid] ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = leftcur+threadid*<span class="number">3</span>+<span class="number">3</span> ; i &lt; size*<span class="number">3</span>  ; i += threadsize*<span class="number">3</span> )</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            vec3fcu next1 = data[i] ;</span><br><span class="line">            vec3fcu next2 = data[i + <span class="number">1</span>] ;</span><br><span class="line">            vec3fcu next3 = data[i + <span class="number">2</span>] ;</span><br><span class="line">            vec3icu nextid = dataid[<span class="built_in"><span class="keyword">int</span></span>(i/<span class="number">3</span>)] ;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">bool</span> cons = <span class="literal">true</span> ;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> g = <span class="number">0</span> ; g&lt; <span class="number">3</span>;g++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> h = <span class="number">0</span> ; h &lt;<span class="number">3</span> ;h++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(leftid[g]==nextid[h])</span><br><span class="line">                    &#123;</span><br><span class="line">                        cons = <span class="literal">false</span> ;</span><br><span class="line">                        <span class="keyword">break</span> ;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(cons&amp;&amp;<span class="built_in">cutri_contact</span>(leftdata1,leftdata2,leftdata3, next1,next2,next3))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> collusion_id = <span class="built_in">atomicAdd</span>(&amp;mutexx,<span class="number">1</span>) ;</span><br><span class="line">                contacted[collusion_id] = i/<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(threadid&lt;mutexx)</span><br><span class="line">        &#123;</span><br><span class="line">            res[blockid*<span class="number">32</span>+threadid+<span class="number">1</span>] = <span class="built_in">vec2fcu</span>(leftcur/<span class="number">3</span>,contacted[threadid]) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(threadid==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res[blockid*<span class="number">32</span>] = <span class="built_in">vec2fcu</span>(mutexx,leftcur/<span class="number">3</span>) ;</span><br><span class="line">            *ressize += mutexx ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h4 id="2-1-2-gpu思路2"><a href="#2-1-2-gpu思路2" class="headerlink" title="2.1.2 gpu思路2"></a>2.1.2 gpu思路2</h4><p>对于最普通的思路，就是全盘继承老师的代码，只不过提供一些关键数据结果和关键数据结构对应方法的GPU支持。<br>在实现过程中，我原来大量使用了Lock struct（参见Cuda by example），以及大量的同步，但是后来经过老师提点，我使用atomicAdd的返回值这个操作，重构了所有的代码，消除了所有的同步。</p>
<blockquote>
<ul>
<li>思路简述：<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1: 将每个三角形的vertex索引序列和所有的vertex数据发送给GPU</span><br><span class="line">2. 在gpu端构建三角形数据，通过tri_contact函数进行求交。</span><br></pre></td></tr></table></figure></li>
<li>方法优点 <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 中规中矩，内存和显存的占用较低。</span><br></pre></td></tr></table></figure></li>
<li>方法坏处：<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. gpu需要在gpu端，通过三角形内部的vertex索引，从vertex数据中重建出整个三角形。</span><br></pre></td></tr></table></figure></li>
<li>实验结果计时：<blockquote>
<p>全部GPU时间<br><img src="/images/2020-11-20-22-36-45.png"><br>核函数时间<br><img src="/images/2020-11-20-22-14-53.png"></p>
<ul>
<li><p>实验结果显示</p>
<p><img src="/images/2020-11-21-00-46-58.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__global__ <span class="keyword">void</span>  <span class="title">gpu_self_check_using_trifs</span><span class="params">(vec3fcu* vtxs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            vec3icu* dataid,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            vec2fcu* res,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">int</span>* ressize,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">int</span> leftstart,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">int</span> leftsize,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> blockid = gridDim.x*blockIdx.y + blockIdx.x ;</span><br><span class="line">    <span class="keyword">int</span> threadid = blockDim.x * threadIdx.y + threadIdx.x ;</span><br><span class="line">    <span class="keyword">int</span> threadsize = blockDim.x * blockDim.y ;</span><br><span class="line">    __shared__ <span class="keyword">int</span> mutexx ;</span><br><span class="line">    __shared__ <span class="keyword">int</span> contacted[<span class="number">32</span>] ;</span><br><span class="line">    mutexx  = <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(blockid&lt;leftsize &amp;&amp; (blockid+leftstart)&lt;size )</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftcur = leftstart + blockid ;</span><br><span class="line">        vec3fcu leftdata1 = vtxs[ dataid[leftcur].x ] ;</span><br><span class="line">        vec3fcu leftdata2 = vtxs[ dataid[leftcur].y ] ;</span><br><span class="line">        vec3fcu leftdata3 = vtxs[ dataid[leftcur].z ] ;</span><br><span class="line">        vec3icu leftid = dataid[leftcur] ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = leftcur+threadid+<span class="number">1</span> ; i &lt; size  ; i += threadsize )</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            vec3fcu next1 = vtxs[ dataid[i].x ] ;</span><br><span class="line">            vec3fcu next2 = vtxs[ dataid[i].y ] ;</span><br><span class="line">            vec3fcu next3 = vtxs[ dataid[i].z ] ;</span><br><span class="line">            vec3icu nextid = dataid[i] ;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">bool</span> cons = <span class="literal">true</span> ;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> g = <span class="number">0</span> ; g&lt; <span class="number">3</span>;g++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> h = <span class="number">0</span> ; h &lt;<span class="number">3</span> ;h++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(leftid[g]==nextid[h])</span><br><span class="line">                    &#123;</span><br><span class="line">                        cons = <span class="literal">false</span> ;</span><br><span class="line">                        <span class="keyword">break</span> ;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(cons&amp;&amp;<span class="built_in">cutri_contact</span>(leftdata1,leftdata2,leftdata3, next1,next2,next3))</span><br><span class="line">            &#123;</span><br><span class="line"><span class="comment">//              记录所有的碰撞操作</span></span><br><span class="line">                <span class="keyword">int</span> collusion_id = <span class="built_in">atomicAdd</span>(&amp;mutexx,<span class="number">1</span>) ;</span><br><span class="line">                contacted[collusion_id] = i;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(threadid&lt;mutexx)</span><br><span class="line">        &#123;</span><br><span class="line">            res[blockid*<span class="number">32</span>+threadid+<span class="number">1</span>] = <span class="built_in">vec2fcu</span>(leftcur,contacted[threadid]) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(threadid==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res[blockid*<span class="number">32</span>] = <span class="built_in">vec2fcu</span>(mutexx,leftcur) ;</span><br><span class="line">            *ressize += mutexx ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h4 id="2-1-3-gpu思路3"><a href="#2-1-3-gpu思路3" class="headerlink" title="2.1.3 gpu思路3"></a>2.1.3 gpu思路3</h4><p>在上面两种思路中，我们对每个三角形之间的相交关系均作判定，但是事实上，我们可以通过BVH这样的包围盒树，快速的过滤大量的没有意义的相交判定，而将相交操作完全限定于某些包围盒相交的三角形之间，这几乎将一个N*N的问题转变成了一个N问题，大大降低了算法的复杂度。但是构建BVH的方法有多种，目前比较流行的包围盒构建方法有3种，第一种为简单BVH，也就是借鉴gis中的KDTree的思想，每次寻找到最长的维度来划分包围盒，构建出整个BVH。 第二种为Morton BVH，也就是借鉴gis中morton码，来代替整个tree结构，因为计算机的0，1位本来就代表了树形分支，所以可以通过一个unsigned int来代表这个包围盒所在的区域位置。考虑到具体的实现难度和性价比（复杂的机制可能并不适合GPU），我们选择了简单BVH。</p>
<blockquote>
<ul>
<li>思路简述：<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1: 给每个三角形构建一个包围盒，并不断merge，得到包含所有三角形包围盒的包围盒。</span><br><span class="line">2. 递归的划分这个最大的包围盒，构建出BVH树。（划分选择最大维度上的中位数包围盒，这样可以保证平衡）</span><br><span class="line">3. 将BVH树型结构转为树形数组。 </span><br><span class="line">4. 将三角形数据，和BVH数组发送到GPU</span><br><span class="line">5. 通过BVH限定碰撞检测的范围</span><br></pre></td></tr></table></figure></li>
<li>方法优点 <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. BVH可以过滤较多没交的三角形，大大加速计算过程。</span><br></pre></td></tr></table></figure></li>
<li>方法坏处：<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 要记录整个BVH的求交的访问结果和过程，要使用stack和队列等。要耗费大量的shared memory，如果shared memory分配的较小，可能会导致相交关系的三角形变少。</span><br></pre></td></tr></table></figure></li>
<li>实验结果计时：<blockquote>
<p>全部GPU时间<br><img src="/images/2020-11-20-23-17-47.png"><br>核函数时间<br><img src="/images/2020-11-20-23-17-09.png"></p>
<ul>
<li><p>实验结果显示<br><img src="/images/2020-11-20-23-21-03.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__global__ <span class="keyword">void</span>  <span class="title">gpu_self_check_using_trifs</span><span class="params">(vec3fcu* data,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            vec3icu* dataid,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            vec2fcu* res,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">int</span>* ressize,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            TreeBoundBox* bvhs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">int</span> bvhsize ,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> blockid = gridDim.x*blockIdx.y + blockIdx.x ;</span><br><span class="line">    <span class="keyword">int</span> threadid = blockDim.x * threadIdx.y + threadIdx.x ;</span><br><span class="line">    <span class="keyword">int</span> threadsize = blockDim.x * blockDim.y ;</span><br><span class="line">    __shared__ <span class="keyword">int</span> mutexx[<span class="number">32</span>] ;</span><br><span class="line">    __shared__ <span class="keyword">int</span> stack[<span class="number">32</span>*<span class="number">32</span>] ;</span><br><span class="line">    __shared__ <span class="keyword">int</span> result[<span class="number">32</span>*<span class="number">32</span>] ;</span><br><span class="line">    mutexx[threadid]  = <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cur = ( blockid*threadsize+threadid)  ;</span><br><span class="line">    <span class="keyword">if</span>(cur&lt;size)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftcur = cur*<span class="number">3</span>  ;</span><br><span class="line">        vec3fcu leftdata1 = data[ leftcur ] ;</span><br><span class="line">        vec3fcu leftdata2 = data[ leftcur + <span class="number">1</span>] ;</span><br><span class="line">        vec3fcu leftdata3 = data[ leftcur + <span class="number">2</span>] ;</span><br><span class="line">        vec3icu leftid = dataid[cur] ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        BoundBox box = <span class="built_in">BoundBox</span>(leftdata1,leftdata2,leftdata3) ;</span><br><span class="line">        <span class="comment">//并将其带入到bvh 得到相撞的size</span></span><br><span class="line">        <span class="keyword">int</span> mysize = <span class="built_in">isInteracted</span>(bvhs,box,cur,bvhsize,stack,result,threadid) ;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (mysize&gt;<span class="number">32</span>?<span class="number">32</span>:mysize)  ; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            vec3fcu next1 = data[(result[threadid*<span class="number">32</span>+i])*<span class="number">3</span>] ;</span><br><span class="line">            vec3fcu next2 = data[(result[threadid*<span class="number">32</span>+i])*<span class="number">3</span> + <span class="number">1</span>] ;</span><br><span class="line">            vec3fcu next3 = data[(result[threadid*<span class="number">32</span>+i])*<span class="number">3</span> + <span class="number">2</span>] ;</span><br><span class="line">            vec3icu nextid = dataid[(result[threadid*<span class="number">32</span>+i])] ;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">bool</span> cons = <span class="literal">true</span> ;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> g = <span class="number">0</span> ; g&lt; <span class="number">3</span>;g++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> h = <span class="number">0</span> ; h &lt;<span class="number">3</span> ;h++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(leftid[g]==nextid[h])</span><br><span class="line">                    &#123;</span><br><span class="line">                        cons = <span class="literal">false</span> ;</span><br><span class="line">                        <span class="keyword">break</span> ;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(cons&amp;&amp;<span class="built_in">cutri_contact</span>(leftdata1,leftdata2,leftdata3, next1,next2,next3))</span><br><span class="line">            &#123;</span><br><span class="line">                mutexx[threadid] = mutexx[threadid]+<span class="number">1</span> ;</span><br><span class="line">                <span class="keyword">if</span>(mutexx[threadid]&lt;<span class="number">31</span>) res[cur*<span class="number">32</span>+mutexx[threadid]] = <span class="built_in">vec2fcu</span>(cur,result[threadid*<span class="number">32</span>+i]) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res[cur*<span class="number">32</span>] = <span class="built_in">vec2fcu</span>(mutexx[threadid],<span class="number">0</span>) ;</span><br><span class="line">        <span class="built_in">atomicAdd</span>(ressize,mutexx[threadid]) ;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h4 id="2-1-4-cpu思路"><a href="#2-1-4-cpu思路" class="headerlink" title="2.1.4 cpu思路"></a>2.1.4 cpu思路</h4><p>使用cpu版本的BVH作为基础，我们可以得出如下的结果</p>
<blockquote>
<ul>
<li>全局时间为：<img src="/images/2020-11-20-23-26-51.png"></li>
<li>最终结果为<br><img src="/images%5C2020-11-20-22-13-021.png"></li>
</ul>
</blockquote>
<h3 id="2-2-相互碰撞检测（补充说明）"><a href="#2-2-相互碰撞检测（补充说明）" class="headerlink" title="2.2 相互碰撞检测（补充说明）"></a>2.2 相互碰撞检测（补充说明）</h3><p><img src="/images/2020-11-20-23-50-54.png"><br><img src="/images/2020-11-20-23-51-14.png"><br>具体的性能比例，同self 碰撞差别不大。</p>
<h2 id="3-遗留问题"><a href="#3-遗留问题" class="headerlink" title="3 遗留问题"></a>3 遗留问题</h2><p>因为1060的显卡限制，所以我使用了float数据结构，有时gpu和cpu的结果可能不同。但差别在10个以内。而且根据上文中的显示结果来看，结果差别并不大。我同样输出了结果在我代码的self_result文件夹中。</p>
<h2 id="4-代码说明"><a href="#4-代码说明" class="headerlink" title="4 代码说明"></a>4 代码说明</h2><blockquote>
<ul>
<li>self_result文件夹存放的是self_result检测结果</li>
<li>您可以修改_Using_BVH_CPU_等宏定义 决定选择不同的方法。</li>
</ul>
</blockquote>
<h2 id="5-总结和展望"><a href="#5-总结和展望" class="headerlink" title="5 总结和展望"></a>5 总结和展望</h2><p>已知，GPU非常善于矩阵运算，nvdia的工程师显著的降低了矩阵运算的时间浪费，因此将所有的运算全部转变为矩阵运算将会大大增加算法的性能，因此我做这个提升性能的工作，我下一步的工作就是想办法将运算完全矩阵化，而且是超大型的矩阵化。</p>
</article></div></main><div class="nav-wrap"><div class="nav"><button class="site-nav"><div class="navicon"></div></button><ul class="nav_items"><li class="nav_item"><a class="nav-page" href="/#Publications"> Publications</a></li><li class="nav_item"><a class="nav-page" href="/"> About</a></li><li class="nav_item"><a class="nav-page" target="_blank" rel="noopener" href="https://crazyweirdo.xyz"> Blog</a></li></ul></div><div class="cd-top"><i class="fa fa-arrow-up" aria-hidden="true"></i></div></div><footer id="page_footer"><div class="footer_wrap"><div class="copyright">&copy;2020 - 2021 by Lidan</div><div class="theme-info">Powered by <a target="_blank" href="https://hexo.io" rel="nofollow noopener">Hexo</a> & <a target="_blank" href="https://github.com/PhosphorW/hexo-theme-academia" rel="nofollow noopener">Academia Theme</a></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery-pjax@latest/jquery.pjax.min.js"></script><script src="/js/main.js"></script></body></html>